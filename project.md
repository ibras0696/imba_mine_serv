Окей, Ибра, без кода — только **мозговой проектный план**, как будто это ТЗ на разработку внутреннего инструмента.

---

## 0. Формат проекта

**Идея:**
Репозиторий, который позволяет любому админy:

* поднять Forge 1.20.1 сервер одной командой
* конфигурить его через `.env`
* класть моды в понятные папки
* запускать всё через Docker Compose + `make`
* без CI/CD, без лишних магий

---

## 1. Определение требований

### 1.1. Функциональные

1. Поднять **один Minecraft Forge 1.20.1 сервер** в контейнере.
2. Конфигурировать сервер через переменные окружения:

   * порт
   * EULA
   * имя сервера
   * сложность, количество игроков
   * выделенная память
3. Подключать **серверные моды** из отдельной папки.
4. Иметь отдельный список **клиентских модов** (чтобы игрокам было понятно, что ставить).
5. Управление через `make`:

   * старт
   * стоп
   * рестарт
   * логи
   * чистка (удаление контейнеров/томов)
6. Возможность запускать на:

   * локальной машине (Windows/Linux/macOS)
   * удалённом Linux-сервере (VPS/dedicated)

### 1.2. Нефункциональные

1. Минимум ручных действий после клонирования репо.
2. Документация такова, чтобы **новичок по Docker смог справиться**.
3. Не лезем в CI/CD, Kubernetes и прочее — сознательный отказ.

---

## 2. Архитектурные решения

### 2.1. Стек

* **Docker** + **Docker Compose** (официальная документация) ([Docker Documentation][1])
* **Forge 1.20.1** (конкретная версия, например recommended из официального сайта Forge) ([Forge Files][2])
* **Java 17 (OpenJDK 17)** как целевая версия JVM ([openjdk.org][3])

### 2.2. Основные принципы

1. **Immutable образ**, но:

   * мир и конфиги → в volume / на хосте
   * моды можно менять без пересборки образа (через монтирование папки)
2. **Одна точка правды для настроек** → `.env`.
3. **Чёткое разделение:**

   * server mods
   * client mods
   * configs
4. Одна `docker-compose.yml` без лишних сервисов.

---

## 3. Структура репозитория (логический дизайн)

Пока только как концепция, без файлов:

* `docker/` — всё, что связано с образом сервера
* `compose/` — docker-compose
* `mods/` — моды и их списки
* `config/` — конфиги
* `env/` — разные env-файлы (пример / локал / прод)
* `docs/` — документация (в т.ч. твой модпак)
* `Makefile` — интерфейс управления
* `README.md` — основной вход

---

## 4. Дизайн управления конфигами и `.env`

### 4.1. Какие параметры выносим в `.env`

Минимальный набор:

* `SERVER_PORT`
* `MEMORY_MIN`, `MEMORY_MAX`
* `EULA`
* `MAX_PLAYERS`
* `DIFFICULTY`
* `ONLINE_MODE`
* `SERVER_NAME`

Расширяемый набор (на будущее):

* `LEVEL_NAME`
* `VIEW_DISTANCE`
* `ALLOW_NETHER`, `PVP`, `ENABLE_COMMAND_BLOCK`

### 4.2. Политика по `.env`

* `env/.env.example` — шаблон, всегда актуальный
* `env/local.env` — для локальных тестов
* `env/production.env` — для удалённого сервера

В документации описать:

1. Как копировать `.env.example` в нужный файл.
2. Какие именно поля надо менять минимум, чтобы запуститься.

---

## 5. Дизайн управления модами

### 5.1. Разделение модов

* `mods/server/`

  * сюда кладутся **.jar**, которые должны быть и на сервере, и у игроков
* `mods/client/`

  * сюда кладём **только списки**:

    * `client-mods.md`
    * возможно, `client-mods.json` с метаданными (имя, версия, ссылка CurseForge)

### 5.2. Документация по модам

В `docs/modpack.md`:

* Таблица модов
* Отдельные секции:

  * **Server-side required**
  * **Client-only**
  * **Optional перфоманс моды**

### 5.3. Политика обновления модов

План:

1. Мод добавляется не “просто кинули .jar”, а:

   * дописывается в `docs/modpack.md` с версией
2. При обновлении:

   * новый `.jar`
   * фикс версии в документации
3. В будущем можно запланировать:

   * полуавтомат через API CurseForge/Modrinth (но сейчас только планируем как future work).

---

## 6. Дизайн Makefile-API (концепция, без реализаций)

Рассматриваем Makefile как **CLI для админа**.

### 6.1. Базовые команды

* `make up` — поднять сервер (создать контейнер, стартануть)
* `make down` — остановить
* `make restart` — рестарт
* `make logs` — показать логи
* `make ps` — показать статус
* `make clean` — снести контейнеры и тома
* `make rebuild` — пересобрать образ (после изменения Docker-конфигурации)

### 6.2. Расширенные команды (на будущее)

* `make backup` — архив мира и конфигов
* `make restore` — восстановление из архива
* `make update-mods` — полуавтоматический поток обновления (пока только концепция).

---

## 7. План тестирования (до того, как писать код)

### 7.1. Сценарии

1. **Чистый запуск без модов**

   * новый пользователь
   * копирует `.env.example` → `local.env`
   * правит порт и название
   * запускает сервер
   * заходит с клиента Vanilla + Forge + 0 модов

2. **Запуск с модами**

   * кладём в `mods/server` базовый набор модов (твоя RPG/Tech сборка)
   * сервер стартует без крашей
   * клиент с тем же набором модов заходит без ошибок

3. **Ошибка в конфиге**

   * некорректное значение в `.env` (например, неверная сложность)
   * ожидаем, что сервер падает с понятной ошибкой или не стартует, а мы документируем это поведение

4. **Перенос проекта**

   * клонирование репо на новый сервер
   * копирование `.env`
   * копирование мира и модов
   * проверка, что всё поднимается без доп. ручной магии

### 7.2. Среды

* локальный dev: Windows + Docker Desktop ([Docker][4])
* удалённый сервер: Ubuntu с установленным Docker Engine ([Docker Documentation][1])

---

## 8. Документация: что должно быть в README

Перед тем как писать, надо чётко решить структуру README:

1. **Описание проекта**
2. **Требования к окружению**

   * Docker
   * Docker Compose
   * минимальные ресурсы (RAM/CPU)
3. **Быстрый старт**

   * шаги “с нуля до работающего сервера”
4. **Структура проекта**
5. **Работа с `.env`**
6. **Работа с модами**
7. **Типовые проблемы и решения**
8. **Ссылки на оф. доки**:

   * Docker docs ([Docker Documentation][1])
   * Docker Compose docs ([Docker Documentation][5])
   * Forge 1.20.1 downloads ([Forge Files][2])
   * Java/OpenJDK 17 docs ([openjdk.org][3])

---

## 9. Этапы разработки (как дорожная карта)

### Этап 0 — Исследование и финальные решения

* выбрать точную версию Forge 1.20.1 (например, **Recommended**)
* зафиксировать Java версию (OpenJDK 17)
* сформировать минимальный список модов для первого теста
* решить OS-хост для прод-сервера (скорее всего Linux)

**Артефакты:**

* `docs/decisions.md` с исходными решениями.

---

### Этап 1 — Скелет репозитория

* создать все папки
* набросать пустые файлы (README, env-ы, docs)
* описать структуру в `README.md` (без тех. деталей реализации)

**Критерий готовности:**

* репо можно открыть, видно структуру, понятно что где будет.

---

### Этап 2 — Проектирование конфигурации и `.env`

* финально утвердить список переменных
* описать в docs:

  * какие обязательные
  * какие опциональные
  * какие имеют дефолты
* прописать правила:

  * не коммитить реальные `.env`
  * всегда обновлять `.env.example`

**Критерий:**

* по `.env.example` новичок понимает, что и за что отвечает.

---

### Этап 3 — Проектирование логики Docker/Compose (без написания Dockerfile)

* на бумаге/в доке решить:

  * какая будет структура образа (где лежит фордж, где мир, где моды)
  * какие директории выносить в volumes
  * какие env переменные будут в Compose
  * как будет называться сервис (например, `minecraft`)

**Критерий:**

* есть документ, по которому любой дев/девопс может спокойно написать Dockerfile и compose.

---

### Этап 4 — Дизайн Makefile-интерфейса

* выписать все команды, их параметры, поведение
* продумать, что делать в `make clean`, чтобы не удалить лишнего случайно
* задокументировать сценарии:

  * “новый пользователь”
  * “админ обновляет сборку”

**Критерий:**

* команда `make` воспринимается как UX-слой для админа.

---

### Этап 5 — Дизайн документации по модам

* описать структуру `docs/modpack.md`
* разбить моды на категории (как мы уже сделали: RPG, Magic, Tech, Optimization)
* продумать формат таблиц:

  * имя мода
  * для кого (server/client/both)
  * версия
  * ссылка на источник (CurseForge/Modrinth)

**Критерий:**

* любой игрок может зайти в docs и понять, что ему ставить на клиент.

---

### Этап 6 — План тестирования и эксплуатации

* сформировать матрицу тестов (сценарии из раздела 7)
* расписать, как админ должен проверять:

  * первый запуск
  * запуск после добавления модов
  * запуск после смены `.env`

**Критерий:**

* есть список проверок, которые НЕ завязаны на конкретной реализации.

---

## 10. Дальше что

Теперь логично следующее шаги:

1. Я могу на основе этого плана сделать **готовый `PLAN.md`** для репозитория (прямо как проектный документ).
2. Потом — отдельно, в другом шаге — начать уже тех. дизайн (без кода, но с более конкретными описаниями Docker/Compose/Makefile).

Если хочешь, скажи:
**“Сделай PLAN.md по этому плану”** — и я оформлю всё в одном аккуратном Markdown-файле, как для реального проекта на GitHub.

[1]: https://docs.docker.com/?utm_source=chatgpt.com "Docker Docs"
[2]: https://files.minecraftforge.net/net/minecraftforge/forge/index_1.20.1.html?utm_source=chatgpt.com "Downloads for Minecraft Forge - MC 1.20.1"
[3]: https://openjdk.org/projects/jdk/17/?utm_source=chatgpt.com "JDK 17"
[4]: https://www.docker.com/products/docker-desktop/?utm_source=chatgpt.com "The #1 containerization software for developers and teams"
[5]: https://docs.docker.com/compose/?utm_source=chatgpt.com "Docker Compose"
